class TableStatus: # Class for representing detail of all tables (capacity, table number etc.)
    def __init__(self, table_number, capacity): 
        self.table_number = table_number # Self used to assign value to instance attribute
        self.capacity = capacity
        self.slots = [None] * 9 # 9 possible slots from 6 to 10:30, None means free 

    def time_to_slot(time): # To convert booking time to slot
        hour, minute = map(int, time.split(':'))
        index = (hour - 18) * 2 + (minute // 30)
        return index
    

    def availability(self, booking_time, duration_hours): 
        start_index = self.time_to_slot(booking_time)
        slots_needed = int(duration_hours * 2) # Convert duration to number of slots needed

        # Increment through slots for availability
        for i in range(start_index, start_index + slots_needed):
            if i >= len(self.slots) or self.slots[i] is not None:
                return False  # Slot not available
        return True
    
    def book_table(self, booking):
        start_index = self.time_to_slot(booking.time)
        slots_needed = int(booking.duration * 2) # Check how many slots required (depending on standard or speedy)
        
        for i in range(start_index, start_index + slots_needed):
            if i < len(self.slots):  
                self.slots[i] = booking  # Stores booking details in occupied slot

    def get_booking_info(self, slot_index):
        booking = self.slots[slot_index]
        if booking:
            return {'surname': booking.surname, 'number_of_people': booking.number_of_people, 'type': booking.booking_type}
        return None
    
    def display_table_bookings(self): # To display the table
        for i, available in enumerate(self.slots):
            hour = 18 + i // 2
            minute = "00" if i % 2 == 0 else "30"
            print(f"{hour}:{minute} - {'Available' if available else 'Booked'}")

class Booking_Details: # Class for detailed booking analysis
    def __init__(self, time, no_of_people, booking_type, surname):
        self.time = time
        self.number_of_people = no_of_people
        self.booking_type = booking_type  
        self.surname = surname
        if booking_type == 'standard':
            self.duration = 1.5 
        else:
            self.duration = 1


class Main_Restaurant: # Class for the main orchestration of the system and handling new bookings
    def __init__(self): # Create table structure: Table(Number, Capacity)
        self.tables = [TableStatus(1, 2), TableStatus(2, 2),  
                       TableStatus(3, 4), TableStatus(4, 4), TableStatus(5, 4),
                       TableStatus(6, 8), TableStatus(7, 8), TableStatus(8, 10)]
        self.bookings = []  # List to hold bookings

    def validate_time(self, booking_time): # Time validation function
        valid_times = [f"{hour:02d}:{minute:02d}" for hour in range(18, 23) for minute in (0, 30)] # As restaurant is open 6pm to 11pm
        valid_times.remove("22:30") # with last booking 10pm
        return booking_time in valid_times

    def validate_capacity(self, booking): # Capacity validation function
        # Several if statements to check which table is appropriate for capacity inputted
        filtered_tables = [t for t in self.tables if t.capacity >= booking.number_of_people and (1 <= booking.number_of_people <= 2 and t.table_number <= 5 or booking.number_of_people >= 6 and t.table_number == 8 or 3 <= booking.number_of_people <= 5 and 3 <= t.table_number <= 5 or booking.number_of_people <= 8 and 6 <= t.table_number <= 7)]
        filtered_tables.sort(key = lambda t: t.capacity)

        for table in filtered_tables:
            if table.availability(booking.time, booking.duration):
                return table
        return None
        
    def new_booking(self): # Function to input a new booking
        while True:  # Main loop for the entire booking process
            booking_time = input("Enter booking time (HH:MM, 24hr format, e.g 20:00 for 8pm): ")
            if not self.validate_time(booking_time): # Check if booking time is in correct format
                print("Invalid booking time. Please choose a time between 6pm and 10pm on the hour or half-hour.")
                continue

            try:
                number_of_people = int(input("Number of people: "))
                if not 1 <= number_of_people <= 10: # Check if number of people is valid
                    raise ValueError("Invalid number of people. Must be between 1 and 10.")
            except ValueError as e:
                print(e)
                continue

            booking_type = input("Type of booking (standard or speedy): ").lower()
            if booking_type not in ['standard', 'speedy']:
                print("Invalid booking type. Please select 'standard' or 'speedy'.")
                continue

            booking_surname = input("Surname of reservation holder: ").strip()
            if not booking_surname:
                print("Surname of reservation holder cannot be empty.")
                break

            added_booking = Booking_Details(booking_time, number_of_people, booking_type, booking_surname) # Create new booking instance
            table = self.validate_capacity(added_booking)

            if table:
                self.confirm(table, added_booking) # Confirm booking
                break
            else:
                if not self.alternative(added_booking): # Check for alternative
                    exit

            if self.place_booking(added_booking):
                print("Successfully booked!")
                break  # Successfully booked, ask to book another
            else:
                print("Cannot book at this time! No alternative found!") # Worst case scenario
                break
    
        
    def confirm(self, table, booking):
        # Confirm with the user before booking
        confirm = input(f"Table {table.table_number} available for {booking.surname} at {booking.time}. Confirm booking? (y/n): ")
        if confirm.lower() == 'y':
            table.book_table(booking)
            self.bookings.append(booking)
            print(f"Booking confirmed for {booking.surname} at table {table.table_number}.")
        else:
            print("Booking not confirmed.")

    def alternative(self, booking):
        
        return True

    def display_table_overview(self):
        column_width = 15
        headers = ["Time"] + [f"Table {t.table_number}" for t in self.tables]
        header_row = "".join(word.ljust(column_width) for word in headers)
        print(header_row)
        print("-" * len(header_row))
        
        time_slots = [f"{hour:02d}:{minute:02d}" for hour in range(18, 23) for minute in (0, 30)]
        time_slots.remove("22:30")  # Last slot starts at 22:00
        
        for time in time_slots:
            row = [time.ljust(column_width)]
            for table in self.tables:
                slot_index = TableStatus.time_to_slot(time)  # Use the static method to get the slot index
                booking_info = table.get_booking_info(slot_index)
                if booking_info:
                    booking_details = f"{booking_info['surname']} {booking_info['number_of_people']} {booking_info['type']}"
                    row.append(booking_details.ljust(column_width))
                else:
                    row.append("Open".ljust(column_width))
            print("".join(row))



def main():
    restaurant = Main_Restaurant()
    print("Initial Table Overview:")
    restaurant.display_table_overview()  # Display an overview of all tables initially
    
    while True:  
        print("\nNew Booking\n")
        restaurant.new_booking()  # Start the booking process
        another = input("Do you want to make another booking? (y/n): ")
        if another.lower() != 'y':
            break
    
    print("\nFinal Bookings Overview:")
    restaurant.display_table_overview()  # Optionally, display the overview again after all bookings

if __name__ == "__main__":
    main()
